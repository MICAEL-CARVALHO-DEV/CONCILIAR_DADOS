/***********************
 * Prototipo SEC Emendas - v3
 * - Status oficial controlado por APG/SUPERVISAO
 * - Marcacao por usuario e timeline completa
 * - Importacao de CSV/XLSX (multiplas abas)
 * - Chave de referencia para duplicidade
 * - Merge de importacao sem perder historico
 ************************/

const STORAGE_KEY = "sec_emendas_prototipo_v3";
const LEGACY_STORAGE_KEYS = ["sec_emendas_prototipo_v2"];

const STATUS = [
  "Recebido",
  "Em analise",
  "Pendente",
  "Aguardando execucao",
  "Em execucao",
  "Aprovado",
  "Concluido",
  "Cancelado"
];
const USER_ROLE_OPTIONS = ["APG", "SUPERVISAO", "CONTABIL", "POWERBI"];
const USER_NAME_KEY = "SEC_USER_NAME";
const USER_ROLE_KEY = "SEC_USER_ROLE";
const API_BASE_URL_KEY = "SEC_API_BASE_URL";
const API_ENABLED_KEY = "SEC_API_ENABLED";
const DEFAULT_API_BASE_URL = "http://localhost:8000";
const DEMO_MULTI_USERS = [
  { name: "Miguel", role: "APG" },
  { name: "Ana", role: "CONTABIL" },
  { name: "Bruno", role: "POWERBI" },
  { name: "Carla", role: "SUPERVISAO" }
];
const DEMO_NOTES = [
  "Aguardando documento complementar.",
  "Validacao contÃ¡bil pendente.",
  "Encaminhado para execuÃ§Ã£o.",
  "Revisado em reuniÃ£o de acompanhamento.",
  "Aguardando retorno do setor responsÃ¡vel."
];

const OFFICIAL_ROLES = new Set(["APG", "SUPERVISAO"]);
const REFERENCE_FIELDS = ["identificacao", "cod_subfonte", "cod_acao", "municipio", "deputado"];

const TRACKED_FIELDS = [
  { key: "ano", label: "Ano", type: "number" },
  { key: "identificacao", label: "Identificacao", type: "string" },
  { key: "cod_subfonte", label: "Cod Subfonte", type: "string" },
  { key: "deputado", label: "Deputado", type: "string" },
  { key: "cod_uo", label: "Cod UO", type: "string" },
  { key: "sigla_uo", label: "Sigla UO", type: "string" },
  { key: "cod_orgao", label: "Cod Orgao", type: "string" },
  { key: "cod_acao", label: "Cod Acao", type: "string" },
  { key: "descricao_acao", label: "Descricao Acao", type: "string" },
  { key: "municipio", label: "Municipio", type: "string" },
  { key: "valor_inicial", label: "Valor Inicial", type: "money" },
  { key: "valor_atual", label: "Valor Atual", type: "money" },
  { key: "processo_sei", label: "Processo SEI", type: "string" }
];

const IMPORT_ALIASES = {
  id: ["id", "id_interno", "id interno", "codigo_interno", "codigo interno"],
  ano: ["ano", "exercicio"],
  identificacao: ["identificacao", "identificacao_emenda", "numero_emenda", "emenda", "identificacao da emenda"],
  cod_subfonte: ["cod_subfonte", "codigo_subfonte", "subfonte", "cod subfonte"],
  deputado: ["deputado", "autor", "parlamentar"],
  cod_uo: ["cod_uo", "codigo_uo", "uo", "cod uo"],
  sigla_uo: ["sigla_uo", "sigla uo", "uo_sigla"],
  cod_orgao: ["cod_orgao", "codigo_orgao", "orgao", "cod orgao"],
  cod_acao: ["cod_acao", "codigo_acao", "acao", "cod acao"],
  descricao_acao: ["descricao_acao", "descricao da acao", "acao_descricao", "descricao"],
  municipio: ["municipio", "cidade"],
  valor_inicial: ["valor_inicial", "valor inicial", "valor_original", "valor original"],
  valor_atual: ["valor_atual", "valor atual", "valor", "valor_emenda", "valor emenda"],
  processo_sei: ["processo_sei", "processo sei", "sei", "processo"],
  status_oficial: ["status_oficial", "status oficial", "status"]
};

const RAW_PREFERRED_HEADERS = {
  id: "ID Interno",
  ano: "Ano",
  identificacao: "IdentificaÃ§Ã£o",
  cod_subfonte: "Cod Subfonte",
  deputado: "Deputado",
  cod_uo: "Cod. UO",
  sigla_uo: "Sigla da UO",
  cod_orgao: "Cod. Ã“rgÃ£o",
  cod_acao: "CÃ³d. da AÃ§Ã£o",
  descricao_acao: "Descritor da AÃ§Ã£o",
  municipio: "MunicÃ­pio / Estado",
  valor_inicial: "Valor Inicial",
  valor_atual: "Valor Atual",
  processo_sei: "Processo SEI",
  status_oficial: "Status"
};

/**
 * Usuario local por maquina:
 * - CURRENT_USER: nome de quem esta usando
 * - CURRENT_ROLE: APG | SUPERVISAO | CONTABIL | POWERBI
 */
let CURRENT_USER = "USER01";
let CURRENT_ROLE = "APG";

loadUserConfig(false);

const DEMO = [
  mkRecord({
    id: "EPI-2026-000001",
    ano: 2026,
    identificacao: "EPI 2026 / Fanfarra",
    cod_subfonte: "SF-10",
    deputado: "DEP-ALFA",
    cod_uo: "1701",
    sigla_uo: "SEPLAN",
    cod_orgao: "17",
    cod_acao: "4023",
    descricao_acao: "Apoio a projetos culturais",
    municipio: "Salvador",
    valor_inicial: 120000,
    valor_atual: 120000,
    processo_sei: "SEI-0001/2026",
    status_oficial: "Recebido",
    eventos: [
      mkEvent("IMPORT", { note: "Registro criado (demo)." }),
      mkEvent("OFFICIAL_STATUS", { from: null, to: "Recebido", note: "Publicacao inicial.", actor_role: "SUPERVISAO", actor_user: "SUP01" }),
      mkEvent("MARK_STATUS", { to: "Em analise", note: "Inicio da analise.", actor_role: "APG", actor_user: "APG01" })
    ]
  }),
  mkRecord({
    id: "EPI-2026-000002",
    ano: 2026,
    identificacao: "EPI 2026 / Reforma Escola",
    cod_subfonte: "SF-20",
    deputado: "DEP-BETA",
    cod_uo: "1701",
    sigla_uo: "SEPLAN",
    cod_orgao: "17",
    cod_acao: "5100",
    descricao_acao: "Reforma de escola estadual",
    municipio: "Feira de Santana",
    valor_inicial: 450000,
    valor_atual: 450000,
    processo_sei: "SEI-0002/2026",
    status_oficial: "Em analise",
    eventos: [
      mkEvent("IMPORT", { note: "Registro criado (demo)." }),
      mkEvent("OFFICIAL_STATUS", { from: null, to: "Em analise", note: "Processo em andamento.", actor_role: "APG", actor_user: "APG02" }),
      mkEvent("MARK_STATUS", { to: "Aguardando execucao", note: "Aguardando ordem de servico.", actor_role: "POWERBI", actor_user: "PBI01" })
    ]
  })
];

let state = loadState();
state.records = (state.records || []).map(normalizeRecordShape);

let selectedId = null;
let idCountersByYear = buildIdCounters(state.records);
let apiOnline = false;
let apiLastError = "";
let apiEmendaIdByInterno = {};
assignMissingIds(state.records, idCountersByYear);
syncReferenceKeys(state.records);
saveState();

const tbody = document.getElementById("tbody");
const statusFilter = document.getElementById("statusFilter");
const yearFilter = document.getElementById("yearFilter");
const searchInput = document.getElementById("searchInput");

const modal = document.getElementById("modal");
const modalTitle = document.getElementById("modalTitle");
const modalSub = document.getElementById("modalSub");
const modalClose = document.getElementById("modalClose");
const modalClose2 = document.getElementById("modalClose2");

const kv = document.getElementById("kv");
const historyEl = document.getElementById("history");
const officialStatus = document.getElementById("officialStatus");
const officialReason = document.getElementById("officialReason");
const btnChangeOfficial = document.getElementById("btnChangeOfficial");

const markStatus = document.getElementById("markStatus");
const markReason = document.getElementById("markReason");
const btnMarkStatus = document.getElementById("btnMarkStatus");
const btnAddNote = document.getElementById("btnAddNote");

const conflictBox = document.getElementById("conflictBox");
const conflictText = document.getElementById("conflictText");
const marksSummary = document.getElementById("marksSummary");
const rawFields = document.getElementById("rawFields");

const btnExport = document.getElementById("btnExport");
const btnExportXlsx = document.getElementById("btnExportXlsx");
const btnExportOne = document.getElementById("btnExportOne");
const btnReset = document.getElementById("btnReset");
const fileCsv = document.getElementById("fileCsv");
const importReport = document.getElementById("importReport");
const importLabel = document.querySelector("label[for='fileCsv']");
const currentUserInfo = document.getElementById("currentUserInfo");
const btnSwitchUser = document.getElementById("btnSwitchUser");
const btnDemo4Users = document.getElementById("btnDemo4Users");

initSelects();
applyAccessProfile();
render();
bootstrapApiIntegration();

function initSelects() {
  setSelectOptions(statusFilter, [{ label: "Todos (status oficial)", value: "" }].concat(STATUS.map(function (s) {
    return { label: s, value: s };
  })));

  setSelectOptions(officialStatus, STATUS.map(function (s) {
    return { label: s, value: s };
  }));

  setSelectOptions(markStatus, STATUS.map(function (s) {
    return { label: s, value: s };
  }));

  syncYearFilter();
}

function syncYearFilter() {
  const current = yearFilter.value;
  const years = Array.from(new Set(state.records.map(function (r) {
    return toInt(r.ano);
  }))).filter(function (y) {
    return y > 0;
  }).sort(function (a, b) {
    return b - a;
  });

  const opts = [{ label: "Todos", value: "" }].concat(years.map(function (y) {
    return { label: String(y), value: String(y) };
  }));

  setSelectOptions(yearFilter, opts, current);
}

function setSelectOptions(select, options, preferredValue) {
  const prev = preferredValue !== undefined ? preferredValue : select.value;
  select.innerHTML = "";
  options.forEach(function (opt) {
    const el = document.createElement("option");
    el.value = opt.value;
    el.textContent = opt.label;
    select.appendChild(el);
  });

  const hasPrev = options.some(function (opt) {
    return opt.value === prev;
  });
  select.value = hasPrev ? prev : options[0].value;
}

function render() {
  const rows = getFiltered();
  tbody.innerHTML = "";

  rows.forEach(function (r) {
    const lastMarks = getLastMarksByUser(r);
    const conflicts = detectConflicts(r, lastMarks);
    const conflictCount = conflicts.length;

    const tr = document.createElement("tr");
    tr.innerHTML = ""
      + "<td><code>" + escapeHtml(r.id) + "</code></td>"
      + "<td>" + escapeHtml(r.identificacao) + "</td>"
      + "<td>" + escapeHtml(r.municipio) + "</td>"
      + "<td>" + escapeHtml(r.deputado) + "</td>"
      + "<td>" + renderStatus(r.status_oficial) + "</td>"
      + "<td>" + (conflictCount ? ("âš  " + conflictCount) : "-") + "</td>"
      + "<td>R$ " + fmtMoney(r.valor_atual) + "</td>"
      + "<td class=\"muted\">" + fmtDateTime(r.updated_at) + "</td>"
      + "<td><button class=\"btn\" data-action=\"view\" data-id=\"" + escapeHtml(r.id) + "\">Ver</button></td>";
    tbody.appendChild(tr);
  });

  Array.prototype.forEach.call(tbody.querySelectorAll("button[data-action='view']"), function (btn) {
    btn.addEventListener("click", function () {
      openModal(btn.dataset.id);
    });
  });
}

function getFiltered() {
  const status = statusFilter.value;
  const year = yearFilter.value;
  const q = (searchInput.value || "").trim().toLowerCase();

  return state.records.filter(function (r) {
    const okStatus = !status || r.status_oficial === status;
    const okYear = !year || String(r.ano) === year;
    const blob = [r.id, r.identificacao, r.municipio, r.deputado, r.processo_sei, r.cod_subfonte, r.cod_acao, r.cod_uo, r.sigla_uo, r.cod_orgao, r.ref_key].join(" ").toLowerCase();
    const okQuery = !q || blob.indexOf(q) >= 0;
    return okStatus && okYear && okQuery;
  }).sort(function (a, b) {
    if (a.id === b.id) return 0;
    return a.id > b.id ? 1 : -1;
  });
}

statusFilter.addEventListener("change", render);
yearFilter.addEventListener("change", render);
searchInput.addEventListener("input", debounce(render, 120));
btnSwitchUser.addEventListener("click", function () {
  loadUserConfig(true);
  applyAccessProfile();
  render();
});
if (btnDemo4Users) {
  btnDemo4Users.addEventListener("click", function () {
    generateRandomMultiUserDemo();
  });
}

modalClose.addEventListener("click", closeModal);
modalClose2.addEventListener("click", closeModal);
modal.addEventListener("click", function (e) {
  if (e.target === modal) closeModal();
});

btnChangeOfficial.addEventListener("click", async function () {
  const rec = getSelected();
  if (!rec) return;

  if (!OFFICIAL_ROLES.has(CURRENT_ROLE)) {
    alert("Somente APG ou SUPERVISAO podem alterar o status oficial.");
    return;
  }

  const next = normalizeStatus(officialStatus.value);
  const why = (officialReason.value || "").trim();
  if (!why) {
    alert("Motivo/observacao e obrigatorio para alterar o status oficial.");
    return;
  }

  const prev = rec.status_oficial;
  rec.status_oficial = next;
  syncCanonicalToAllFields(rec);
  rec.updated_at = isoNow();
  rec.eventos.unshift(mkEvent("OFFICIAL_STATUS", { from: prev, to: next, note: why }));

  try {
    await syncOfficialStatusToApi(rec, next, why);
  } catch (err) {
    handleApiSyncError(err, "status oficial");
  }

  saveState();
  render();
  openModal(rec.id, true);
});

btnMarkStatus.addEventListener("click", async function () {
  const rec = getSelected();
  if (!rec) return;

  const next = normalizeStatus(markStatus.value);
  const why = (markReason.value || "").trim();
  if (!why) {
    alert("Motivo/observacao e obrigatorio para registrar marcacao.");
    return;
  }

  rec.updated_at = isoNow();
  rec.eventos.unshift(mkEvent("MARK_STATUS", { to: next, note: why }));

  try {
    await syncGenericEventToApi(rec, {
      usuario_nome: CURRENT_USER,
      setor: CURRENT_ROLE,
      tipo_evento: "MARK_STATUS",
      valor_novo: next,
      motivo: why
    });
  } catch (err) {
    handleApiSyncError(err, "marcacao");
  }

  saveState();
  render();
  openModal(rec.id, true);
});

btnAddNote.addEventListener("click", async function () {
  const rec = getSelected();
  if (!rec) return;

  const why = (markReason.value || "").trim();
  if (!why) {
    alert("Escreva uma observacao para registrar no historico.");
    return;
  }

  rec.updated_at = isoNow();
  rec.eventos.unshift(mkEvent("NOTE", { note: why }));

  try {
    await syncGenericEventToApi(rec, {
      usuario_nome: CURRENT_USER,
      setor: CURRENT_ROLE,
      tipo_evento: "NOTE",
      motivo: why
    });
  } catch (err) {
    handleApiSyncError(err, "nota");
  }

  saveState();
  render();
  openModal(rec.id, true);
});

btnExportOne.addEventListener("click", function () {
  const rec = getSelected();
  if (!rec) return;
  downloadCsv("emenda_" + rec.id + ".csv", toCsv([rec]));
});

btnExport.addEventListener("click", function () {
  downloadCsv("emendas_export_" + dateStamp() + ".csv", toCsv(state.records));
});

btnExportXlsx.addEventListener("click", function () {
  exportRecordsToXlsx(state.records, "emendas_export_" + dateStamp() + ".xlsx");
});

btnReset.addEventListener("click", function () {
  if (!confirm("Resetar para dados DEMO? Isso apaga alteracoes locais.")) return;
  state = { records: deepClone(DEMO).map(normalizeRecordShape) };
  idCountersByYear = buildIdCounters(state.records);
  assignMissingIds(state.records, idCountersByYear);
  syncReferenceKeys(state.records);
  saveState();
  syncYearFilter();
  render();
  closeModal();
  hideImportReport();
});

fileCsv.addEventListener("change", async function () {
  const file = fileCsv.files && fileCsv.files[0];
  if (!file) return;

  try {
    const sourceRows = await parseInputFile(file);
    if (!sourceRows.length) {
      alert("Nenhuma linha valida encontrada no arquivo.");
      hideImportReport();
      return;
    }

    const report = processImportedRows(sourceRows, file.name);
    saveState();
    syncYearFilter();
    render();
    showImportReport(report);

    alert("Importacao concluida. Criados: " + report.created + " | Atualizados: " + report.updated + " | Sem alteracao: " + report.unchanged + " | Linhas lidas: " + report.totalRows);
  } catch (err) {
    console.error(err);
    const detail = err && err.message ? String(err.message) : "erro desconhecido";
    const hint = detail.includes("Biblioteca XLSX nao carregada") ? " Dica: abra por http://127.0.0.1:5500 e confirme internet para carregar a biblioteca XLSX." : "";
    alert("Falha ao importar arquivo. Detalhe: " + detail + hint);
  } finally {
    fileCsv.value = "";
  }
});

function openModal(id, keepReasons) {
  selectedId = id;
  const rec = getSelected();
  if (!rec) return;

  modalTitle.textContent = "Emenda: " + rec.id;
  modalSub.textContent = rec.identificacao + " | " + rec.municipio + " | " + rec.deputado;

  officialStatus.value = normalizeStatus(rec.status_oficial);
  if (!keepReasons) {
    officialReason.value = "";
    markReason.value = "";
  }

  kv.innerHTML = "";
  const pairs = [
    ["Ano", rec.ano],
    ["Status Oficial", rec.status_oficial],
    ["Identificacao", rec.identificacao],
    ["Cod Subfonte", rec.cod_subfonte || "-"],
    ["Cod Acao", rec.cod_acao || "-"],
    ["Descricao Acao", rec.descricao_acao || "-"],
    ["Municipio", rec.municipio],
    ["Deputado", rec.deputado],
    ["Cod UO", rec.cod_uo || "-"],
    ["Sigla UO", rec.sigla_uo || "-"],
    ["Cod Orgao", rec.cod_orgao || "-"],
    ["Valor Inicial", "R$ " + fmtMoney(rec.valor_inicial)],
    ["Valor Atual", "R$ " + fmtMoney(rec.valor_atual)],
    ["Processo SEI", rec.processo_sei || "-"],
    ["Ref Key", rec.ref_key || "-"]
  ];
  pairs.forEach(function (pair) {
    const item = document.createElement("div");
    item.className = "item";
    item.innerHTML = "<div class=\"k\">" + escapeHtml(pair[0]) + "</div><div class=\"v\">" + escapeHtml(String(pair[1])) + "</div>";
    kv.appendChild(item);
  });

  const lastMarks = getLastMarksByUser(rec);
  renderMarksSummary(lastMarks);
  renderRawFields(rec);

  const conflicts = detectConflicts(rec, lastMarks);
  if (conflicts.length) {
    conflictBox.classList.remove("hidden");
    conflictText.textContent = "Status Oficial = \"" + rec.status_oficial + "\". Divergencias: " + conflicts.join(" | ");
  } else {
    conflictBox.classList.add("hidden");
    conflictText.textContent = "";
  }

  historyEl.innerHTML = "";
  getEventsSorted(rec).forEach(function (ev) {
    const div = document.createElement("div");
    div.className = "event";

    const who = (ev.actor_role || "-") + " | " + (ev.actor_user || "-");
    let right = "";
    if (ev.type === "OFFICIAL_STATUS") {
      right = "<b>" + escapeHtml(ev.from || "") + "</b> -> <b>" + escapeHtml(ev.to || "") + "</b>";
    } else if (ev.type === "MARK_STATUS") {
      right = "<b>" + escapeHtml(ev.to || "") + "</b>";
    } else if (ev.type === "EDIT_FIELD") {
      right = "<b>" + escapeHtml(ev.field || "") + "</b>: " + escapeHtml(String(ev.from || "")) + " -> " + escapeHtml(String(ev.to || ""));
    }

    div.innerHTML = ""
      + "<div class=\"top\">"
      + "<div class=\"meta\"><b>" + escapeHtml(who) + "</b> | " + fmtDateTime(ev.at) + " | <span class=\"muted\">" + escapeHtml(ev.type) + "</span></div>"
      + "<div class=\"meta\">" + right + "</div>"
      + "</div>"
      + "<div class=\"desc\">" + escapeHtml(ev.note || "") + "</div>";
    historyEl.appendChild(div);
  });

  modal.classList.add("show");
  modal.setAttribute("aria-hidden", "false");
}

function renderRawFields(rec) {
  if (!rawFields) return;
  const obj = rec && rec.all_fields && typeof rec.all_fields === "object" ? rec.all_fields : {};
  const keys = Object.keys(obj);

  if (!keys.length) {
    rawFields.innerHTML = "<p class=\"muted small\">Sem campos brutos importados.</p>";
    return;
  }

  let html = "<table class=\"table\" style=\"min-width:760px\"><thead><tr><th>Campo</th><th>Valor</th></tr></thead><tbody>";
  keys.forEach(function (k) {
    html += "<tr><td><code>" + escapeHtml(k) + "</code></td><td>" + escapeHtml(String(obj[k] == null ? "" : obj[k])) + "</td></tr>";
  });
  html += "</tbody></table>";
  rawFields.innerHTML = html;
}

function getEventsSorted(rec) {
  return (rec.eventos || []).slice().sort(function (a, b) {
    const ta = new Date(a.at).getTime() || 0;
    const tb = new Date(b.at).getTime() || 0;
    return tb - ta;
  });
}

function renderMarksSummary(lastMarks) {
  const entries = Object.entries(lastMarks).sort(function (a, b) {
    if (a[0] === b[0]) return 0;
    return a[0] > b[0] ? 1 : -1;
  });

  let html = ""
    + "<table class=\"table\" style=\"min-width:700px\">"
    + "<thead><tr>"
    + "<th>Usuario</th><th>Setor</th><th>Ultima marcacao</th><th>Data/Hora</th><th>Observacao</th>"
    + "</tr></thead><tbody>";

  entries.forEach(function (entry) {
    const user = entry[0];
    const info = entry[1];
    html += "<tr>"
      + "<td><code>" + escapeHtml(user) + "</code></td>"
      + "<td>" + escapeHtml(info.role || "-") + "</td>"
      + "<td>" + renderStatus(info.status || "-") + "</td>"
      + "<td class=\"muted\">" + fmtDateTime(info.at) + "</td>"
      + "<td>" + escapeHtml(info.note || "") + "</td>"
      + "</tr>";
  });

  if (!entries.length) {
    html += "<tr><td colspan=\"5\" class=\"muted\">Nenhuma marcacao registrada ainda.</td></tr>";
  }

  html += "</tbody></table>";
  marksSummary.innerHTML = html;
}

function getLastMarksByUser(rec) {
  const map = {};
  getEventsSorted(rec).forEach(function (ev) {
    if (ev.type !== "MARK_STATUS") return;
    const user = ev.actor_user;
    if (!user || map[user]) return;
    map[user] = { role: ev.actor_role, status: ev.to, at: ev.at, note: ev.note };
  });
  return map;
}

function detectConflicts(rec, lastMarks) {
  const conflicts = [];
  const official = rec.status_oficial;
  Object.entries(lastMarks).forEach(function (entry) {
    const user = entry[0];
    const info = entry[1];
    if (info.status && info.status !== official) {
      conflicts.push((info.role || "-") + "/" + user + ": " + info.status);
    }
  });
  return conflicts;
}

function closeModal() {
  modal.classList.remove("show");
  modal.setAttribute("aria-hidden", "true");
  selectedId = null;
}

function getSelected() {
  return state.records.find(function (r) {
    return r.id === selectedId;
  });
}

function processImportedRows(sourceRows, fileName) {
  const report = {
    fileName: fileName,
    totalRows: sourceRows.length,
    consideredRows: 0,
    skippedRows: 0,
    created: 0,
    updated: 0,
    unchanged: 0,
    duplicateById: 0,
    duplicateByRef: 0,
    duplicateInFile: 0,
    conflictIdVsRef: 0,
    sheetNames: []
  };

  const sheetSet = new Set();
  const existingById = new Map();
  const existingByRef = new Map();
  const seenImportRef = new Set();

  state.records.forEach(function (rec) {
    existingById.set(rec.id, rec);
    if (rec.ref_key && !existingByRef.has(rec.ref_key)) existingByRef.set(rec.ref_key, rec);
  });

  sourceRows.forEach(function (ctx) {
    sheetSet.add(ctx.sheetName || "CSV");
    const incoming = mapImportRow(ctx);

    if (!hasUsefulData(incoming)) {
      report.skippedRows += 1;
      return;
    }
    report.consideredRows += 1;

    if (incoming.ref_key) {
      if (seenImportRef.has(incoming.ref_key)) report.duplicateInFile += 1;
      seenImportRef.add(incoming.ref_key);
    }

    const byId = incoming.id ? existingById.get(incoming.id) : null;
    const byRef = incoming.ref_key ? existingByRef.get(incoming.ref_key) : null;

    if (byId) report.duplicateById += 1;
    if (!byId && byRef) report.duplicateByRef += 1;

    let target = byId || byRef || null;
    if (byId && byRef && byId !== byRef) {
      report.conflictIdVsRef += 1;
      target = byId;
    }

    if (!target) {
      const created = createRecordFromImport(incoming, ctx, fileName);
      state.records.push(created);
      existingById.set(created.id, created);
      if (created.ref_key && !existingByRef.has(created.ref_key)) existingByRef.set(created.ref_key, created);
      report.created += 1;
      return;
    }

    const mergeResult = mergeImportIntoRecord(target, incoming, ctx, fileName);
    if (mergeResult.changedAny) report.updated += 1;
    else report.unchanged += 1;

    existingById.set(target.id, target);
    if (target.ref_key) existingByRef.set(target.ref_key, target);
  });

  report.sheetNames = Array.from(sheetSet);
  return report;
}

function createRecordFromImport(incoming, ctx, fileName) {
  const now = isoNow();
  const ano = incoming.ano || currentYear();
  const id = incoming.id || generateInternalId(ano, idCountersByYear);
  const status = incoming.status_oficial || "Recebido";

  const base = mkRecord({
    id: id,
    ano: ano,
    identificacao: incoming.identificacao || "-",
    cod_subfonte: incoming.cod_subfonte || "",
    deputado: incoming.deputado || "-",
    cod_uo: incoming.cod_uo || "",
    sigla_uo: incoming.sigla_uo || "",
    cod_orgao: incoming.cod_orgao || "",
    cod_acao: incoming.cod_acao || "",
    descricao_acao: incoming.descricao_acao || "",
    municipio: incoming.municipio || "-",
    valor_inicial: incoming.valor_inicial != null ? incoming.valor_inicial : (incoming.valor_atual != null ? incoming.valor_atual : 0),
    valor_atual: incoming.valor_atual != null ? incoming.valor_atual : (incoming.valor_inicial != null ? incoming.valor_inicial : 0),
    processo_sei: incoming.processo_sei || "",
    status_oficial: status,
    created_at: now,
    updated_at: now,
    source_sheet: incoming.source_sheet || ctx.sheetName || "Controle de EPI",
    source_row: ctx.rowNumber != null ? Number(ctx.rowNumber) : null,
    all_fields: shallowCloneObj(incoming.all_fields || {}),
    eventos: [
      mkEvent("IMPORT", { note: buildImportNote(fileName, ctx) }),
      mkEvent("OFFICIAL_STATUS", { from: null, to: status, note: "Status oficial definido na importacao." })
    ]
  });
  base.ref_key = buildReferenceKey(base);
  return base;
}

function mergeImportIntoRecord(target, incoming, ctx, fileName) {
  const changedEvents = [];
  let changedAny = false;

  const rawMergeChanged = mergeRawFields(target, incoming.all_fields || {});
  if (rawMergeChanged) changedAny = true;

  if (incoming.source_sheet) target.source_sheet = incoming.source_sheet;
  if (ctx.rowNumber != null) target.source_row = Number(ctx.rowNumber);

  TRACKED_FIELDS.forEach(function (def) {
    const nextRaw = incoming[def.key];
    if (!hasIncomingValue(nextRaw, def.type)) return;

    const prev = target[def.key];
    if (!hasFieldChanged(prev, nextRaw, def.type)) return;

    if (def.type === "money" || def.type === "number") target[def.key] = Number(nextRaw);
    else target[def.key] = String(nextRaw).trim();

    changedEvents.push(mkEvent("EDIT_FIELD", {
      field: def.label,
      from: stringifyFieldValue(prev, def.type),
      to: stringifyFieldValue(target[def.key], def.type),
      note: "Atualizado via importacao."
    }));
    changedAny = true;
  });

  if (incoming.status_oficial) {
    const prevStatus = normalizeStatus(target.status_oficial);
    const nextStatus = normalizeStatus(incoming.status_oficial);
    if (prevStatus !== nextStatus) {
      target.status_oficial = nextStatus;
      changedEvents.push(mkEvent("OFFICIAL_STATUS", { from: prevStatus, to: nextStatus, note: "Atualizado via importacao." }));
      changedAny = true;
    }
  }

  const oldRef = target.ref_key || "";
  syncCanonicalToAllFields(target);
  target.ref_key = buildReferenceKey(target);
  if (oldRef !== target.ref_key) {
    changedEvents.push(mkEvent("EDIT_FIELD", { field: "Chave Referencia", from: oldRef, to: target.ref_key, note: "Recalculada apos importacao." }));
    changedAny = true;
  }

  target.updated_at = isoNow();
  changedEvents.push(mkEvent("IMPORT", { note: buildImportNote(fileName, ctx) + (changedAny ? " (com atualizacoes)" : " (sem alteracoes)") }));
  target.eventos = changedEvents.concat(target.eventos || []);

  return { changedAny: changedAny };
}

function mapImportRow(ctx) {
  const rawOriginal = shallowCloneObj(ctx.row || {});
  const row = normalizeRowKeys(rawOriginal);

  const ano = toInt(pickValue(row, IMPORT_ALIASES.ano));
  const identificacao = asText(pickValue(row, IMPORT_ALIASES.identificacao));
  const codSubfonte = asText(pickValue(row, IMPORT_ALIASES.cod_subfonte));
  const codAcao = asText(pickValue(row, IMPORT_ALIASES.cod_acao));
  const municipio = asText(pickValue(row, IMPORT_ALIASES.municipio));
  const deputado = asText(pickValue(row, IMPORT_ALIASES.deputado));

  const record = {
    id: asText(pickValue(row, IMPORT_ALIASES.id)),
    ano: ano || currentYear(),
    identificacao: identificacao,
    cod_subfonte: codSubfonte,
    deputado: deputado,
    cod_uo: asText(pickValue(row, IMPORT_ALIASES.cod_uo)),
    sigla_uo: asText(pickValue(row, IMPORT_ALIASES.sigla_uo)),
    cod_orgao: asText(pickValue(row, IMPORT_ALIASES.cod_orgao)),
    cod_acao: codAcao,
    descricao_acao: asText(pickValue(row, IMPORT_ALIASES.descricao_acao)),
    municipio: municipio,
    valor_inicial: toNumberOrNull(pickValue(row, IMPORT_ALIASES.valor_inicial)),
    valor_atual: toNumberOrNull(pickValue(row, IMPORT_ALIASES.valor_atual)),
    processo_sei: asText(pickValue(row, IMPORT_ALIASES.processo_sei)),
    status_oficial: "",
    all_fields: rawOriginal,
    source_sheet: ctx.sheetName || "CSV",
    source_row: ctx.rowNumber != null ? Number(ctx.rowNumber) : null
  };

  const statusRaw = asText(pickValue(row, IMPORT_ALIASES.status_oficial));
  if (statusRaw) record.status_oficial = normalizeStatus(statusRaw);

  syncCanonicalToAllFields(record);
  record.ref_key = buildReferenceKey(record);
  return record;
}

function hasUsefulData(record) {
  const checks = [record.id, record.identificacao, record.cod_subfonte, record.cod_acao, record.municipio, record.deputado, record.processo_sei, record.ref_key];
  const hasText = checks.some(function (v) {
    return !!String(v || "").trim();
  });
  const hasNumber = record.valor_inicial != null || record.valor_atual != null;
  return hasText || hasNumber;
}

function hasIncomingValue(value, type) {
  if (type === "money" || type === "number") return value != null && String(value).trim() !== "" && Number.isFinite(Number(value));
  return value != null && String(value).trim() !== "";
}

function hasFieldChanged(prev, next, type) {
  if (type === "money") return toNumber(prev) !== toNumber(next);
  if (type === "number") return toInt(prev) !== toInt(next);
  return normalizeLooseText(prev) !== normalizeLooseText(next);
}

function stringifyFieldValue(value, type) {
  if (type === "money") return "R$ " + fmtMoney(value);
  if (type === "number") return String(toInt(value));
  return String(value == null ? "" : value);
}

function buildImportNote(fileName, ctx) {
  return "Importado de " + fileName + " | Aba: " + (ctx.sheetName || "CSV") + " | Linha: " + String(ctx.rowNumber || "-");
}

async function parseInputFile(file) {
  const name = String(file.name || "").toLowerCase();

  if (name.endsWith(".csv")) {
    const text = await file.text();
    const rows = parseCsv(text);
    return rows.map(function (row, idx) {
      return { sheetName: "CSV", rowNumber: idx + 2, row: row };
    });
  }

  if (name.endsWith(".xlsx") || name.endsWith(".xls")) {
    const xlsxApi = typeof window !== "undefined" ? window.XLSX : null;
    if (!xlsxApi) throw new Error("Biblioteca XLSX nao carregada.");

    const buffer = await file.arrayBuffer();
    const wb = xlsxApi.read(buffer, { type: "array" });
    const out = [];

    wb.SheetNames.forEach(function (sheetName) {
      const sheet = wb.Sheets[sheetName];
      const matrix = xlsxApi.utils.sheet_to_json(sheet, { header: 1, defval: "", raw: false, blankrows: false });
      const detected = detectHeaderRow(matrix);
      if (!detected) return;

      const headers = detected.headers;
      for (let r = detected.headerRowIndex + 1; r < matrix.length; r += 1) {
        const arr = matrix[r] || [];
        if (isRowEmpty(arr)) continue;
        const rowObj = rowArrayToObject(arr, headers);
        out.push({ sheetName: sheetName, rowNumber: r + 1, row: rowObj });
      }
    });

    return out;
  }

  throw new Error("Formato nao suportado. Use CSV ou XLSX.");
}

function detectHeaderRow(matrix) {
  if (!Array.isArray(matrix) || !matrix.length) return null;

  const scanLimit = Math.min(matrix.length, 40);
  let bestIndex = -1;
  let bestScore = -1;

  for (let i = 0; i < scanLimit; i += 1) {
    const row = Array.isArray(matrix[i]) ? matrix[i] : [];
    const nonEmpty = row.filter(function (v) {
      return text(v) !== "";
    }).length;
    if (nonEmpty < 3) continue;

    const normalized = row.map(function (v) { return normalizeHeader(v); });
    let score = nonEmpty;
    const hints = ["identificacao", "deputado", "status", "municipio", "cod_uo", "cod_subfonte", "cod_da_acao", "descritor_da_acao"];
    hints.forEach(function (h) {
      if (normalized.includes(h)) score += 5;
    });

    if (score > bestScore) {
      bestScore = score;
      bestIndex = i;
    }
  }

  if (bestIndex < 0) return null;
  const rawHeader = Array.isArray(matrix[bestIndex]) ? matrix[bestIndex] : [];
  const headers = buildHeadersFromRow(rawHeader);
  return { headerRowIndex: bestIndex, headers: headers };
}

function buildHeadersFromRow(rawHeader) {
  const out = [];
  const used = {};
  const total = Math.max(rawHeader.length, 1);

  for (let i = 0; i < total; i += 1) {
    let base = text(rawHeader[i]);
    if (!base) base = "COL_" + String(i + 1);

    let key = base;
    let n = 2;
    while (used[key]) {
      key = base + "_" + String(n);
      n += 1;
    }
    used[key] = true;
    out.push(key);
  }

  return out;
}

function rowArrayToObject(arr, headers) {
  const obj = {};
  for (let c = 0; c < headers.length; c += 1) {
    const key = headers[c];
    if (!key) continue;
    obj[key] = arr[c] == null ? "" : String(arr[c]).trim();
  }
  return obj;
}

function isRowEmpty(arr) {
  if (!Array.isArray(arr)) return true;
  return !arr.some(function (v) {
    return text(v) !== "";
  });
}

function renderStatus(status) {
  const color = statusColor(status);
  return "<span class=\"badge\"><span class=\"dot\" style=\"background:" + color + "\"></span>" + escapeHtml(status) + "</span>";
}

function statusColor(status) {
  if (status === "Concluido") return "#2ecc71";
  if (status === "Cancelado") return "#ff4f6d";
  if (status === "Pendente") return "#f1c40f";
  if (status === "Aguardando execucao") return "#f39c12";
  if (status === "Em execucao") return "#3498db";
  if (status === "Em analise") return "#4f8cff";
  if (status === "Aprovado") return "#9b59b6";
  return "#95a5a6";
}

function normalizeStatus(input) {
  const cleaned = normalizeLooseText(input);
  if (!cleaned) return "Recebido";
  const found = STATUS.find(function (st) {
    return normalizeLooseText(st) === cleaned;
  });
  return found || "Recebido";
}


function generateRandomMultiUserDemo() {
  if (!Array.isArray(state.records) || state.records.length === 0) {
    state = { records: deepClone(DEMO).map(normalizeRecordShape) };
  }

  const sampleSize = Math.min(state.records.length, 20);
  const targets = state.records.slice(0, sampleSize);

  targets.forEach(function (rec, idx) {
    for (let i = 0; i < DEMO_MULTI_USERS.length; i += 1) {
      const u = DEMO_MULTI_USERS[i];
      const st = pickRandom(STATUS);
      const note = pickRandom(DEMO_NOTES) + " [demo #" + String(idx + 1) + "]";
      rec.eventos.unshift(mkEvent("MARK_STATUS", {
        to: st,
        note: note,
        actor_user: u.name,
        actor_role: u.role
      }));
    }

    const nextOfficial = pickRandom(STATUS);
    rec.eventos.unshift(mkEvent("OFFICIAL_STATUS", {
      from: rec.status_oficial,
      to: nextOfficial,
      note: "Atualizacao oficial automatica de demonstraÃ§Ã£o.",
      actor_user: "Carla",
      actor_role: "SUPERVISAO"
    }));

    rec.status_oficial = nextOfficial;
    rec.updated_at = isoNow();
    syncCanonicalToAllFields(rec);
  });

  saveState();
  syncYearFilter();
  render();
  alert("Demo aplicada: 4 usuarios com eventos aleatorios em " + String(sampleSize) + " emendas.");
}

function pickRandom(arr) {
  if (!arr || !arr.length) return "";
  const i = Math.floor(Math.random() * arr.length);
  return arr[i];
}
function loadUserConfig(forcePrompt) {
  const legacyUser = localStorage.getItem("SEC_USER_ID");
  const savedUser = localStorage.getItem(USER_NAME_KEY) || legacyUser;
  const savedRole = localStorage.getItem(USER_ROLE_KEY);

  if (savedUser) CURRENT_USER = String(savedUser).trim() || CURRENT_USER;
  if (savedRole) CURRENT_ROLE = normalizeUserRole(savedRole);

  if (forcePrompt || !savedUser || !savedRole) {
    const nameInput = prompt("Informe seu nome (ex.: Miguel):", savedUser || CURRENT_USER) || CURRENT_USER;
    const roleInput = prompt("Informe seu setor (APG | SUPERVISAO | CONTABIL | POWERBI):", savedRole || CURRENT_ROLE) || CURRENT_ROLE;

    CURRENT_USER = String(nameInput).trim() || CURRENT_USER;
    CURRENT_ROLE = normalizeUserRole(roleInput);

    localStorage.setItem(USER_NAME_KEY, CURRENT_USER);
    localStorage.setItem(USER_ROLE_KEY, CURRENT_ROLE);
  }
}

function applyAccessProfile() {
  const isSupervisor = CURRENT_ROLE === "SUPERVISAO";
  const canManageData = isSupervisor || CURRENT_ROLE === "APG";
  const apiTag = apiOnline ? "API online" : "modo local";

  if (currentUserInfo) {
    currentUserInfo.textContent = "Usuario: " + CURRENT_USER + " / " + CURRENT_ROLE + (isSupervisor ? " (visao geral)" : "") + " | " + apiTag;
  }

  if (btnExport) btnExport.style.display = canManageData ? "inline-block" : "none";
  if (btnExportXlsx) btnExportXlsx.style.display = canManageData ? "inline-block" : "none";
  if (importLabel) importLabel.style.display = canManageData ? "inline-block" : "none";
  if (btnReset) btnReset.style.display = canManageData ? "inline-block" : "none";
  if (btnDemo4Users) btnDemo4Users.style.display = canManageData ? "inline-block" : "none";
}

async function bootstrapApiIntegration() {
  if (!isApiEnabled()) {
    apiOnline = false;
    applyAccessProfile();
    return;
  }

  try {
    await apiRequest("GET", "/health");
    const remoteList = await apiRequest("GET", "/emendas");
    mergeRemoteEmendas(Array.isArray(remoteList) ? remoteList : []);
    apiOnline = true;
    apiLastError = "";
  } catch (err) {
    apiOnline = false;
    apiLastError = err && err.message ? String(err.message) : "falha de conexao";
    console.warn("API indisponivel, mantendo modo local:", apiLastError);
  }

  saveState();
  syncYearFilter();
  applyAccessProfile();
  render();
}

function mergeRemoteEmendas(remoteList) {
  const localByInternal = {};
  state.records.forEach(function (r) {
    localByInternal[r.id] = r;
  });

  remoteList.forEach(function (re) {
    const idInterno = text(re.id_interno);
    if (!idInterno) return;

    apiEmendaIdByInterno[idInterno] = Number(re.id);

    const local = localByInternal[idInterno];
    if (local) {
      local.backend_id = Number(re.id);
      local.status_oficial = normalizeStatus(re.status_oficial || local.status_oficial);
      if (re.updated_at) local.updated_at = String(re.updated_at);
      syncCanonicalToAllFields(local);
      return;
    }

    const novo = mkRecord({
      id: idInterno,
      backend_id: Number(re.id),
      ano: toInt(re.ano) || currentYear(),
      identificacao: text(re.identificacao) || "-",
      status_oficial: normalizeStatus(re.status_oficial || "Recebido"),
      updated_at: re.updated_at || isoNow(),
      eventos: [mkEvent("IMPORT", { note: "Carregado da API." })]
    });

    state.records.push(novo);
  });
}

async function syncOfficialStatusToApi(rec, nextStatus, motivo) {
  if (!isApiEnabled()) return;
  const backendId = await ensureBackendEmenda(rec);
  await apiRequest("POST", "/emendas/" + String(backendId) + "/status", {
    usuario_nome: CURRENT_USER,
    setor: CURRENT_ROLE,
    novo_status: nextStatus,
    motivo: motivo
  });
  apiOnline = true;
  apiLastError = "";
  applyAccessProfile();
}

async function syncGenericEventToApi(rec, payload) {
  if (!isApiEnabled()) return;
  const backendId = await ensureBackendEmenda(rec);
  await apiRequest("POST", "/emendas/" + String(backendId) + "/eventos", payload);
  apiOnline = true;
  apiLastError = "";
  applyAccessProfile();
}

async function ensureBackendEmenda(rec) {
  if (rec.backend_id) return rec.backend_id;

  const known = apiEmendaIdByInterno[rec.id];
  if (known) {
    rec.backend_id = Number(known);
    return rec.backend_id;
  }

  const remoteList = await apiRequest("GET", "/emendas");
  const found = (Array.isArray(remoteList) ? remoteList : []).find(function (x) {
    return text(x.id_interno) === rec.id;
  });

  if (found) {
    rec.backend_id = Number(found.id);
    apiEmendaIdByInterno[rec.id] = rec.backend_id;
    return rec.backend_id;
  }

  const created = await apiRequest("POST", "/emendas", {
    id_interno: rec.id,
    ano: toInt(rec.ano) || currentYear(),
    identificacao: rec.identificacao || "-",
    status_oficial: normalizeStatus(rec.status_oficial || "Recebido")
  });

  rec.backend_id = created && created.id != null ? Number(created.id) : null;
  if (rec.backend_id) apiEmendaIdByInterno[rec.id] = rec.backend_id;
  return rec.backend_id;
}

function isApiEnabled() {
  const raw = localStorage.getItem(API_ENABLED_KEY);
  if (raw == null || raw === "") return true;
  return String(raw).trim().toLowerCase() !== "false";
}

function getApiBaseUrl() {
  const raw = localStorage.getItem(API_BASE_URL_KEY);
  const base = text(raw) || DEFAULT_API_BASE_URL;
  return base.replace(/\/+$/, "");
}

async function apiRequest(method, path, body) {
  const url = getApiBaseUrl() + path;
  const opts = { method: method, headers: {} };
  if (body !== undefined) {
    opts.headers["Content-Type"] = "application/json";
    opts.body = JSON.stringify(body);
  }

  let resp;
  try {
    resp = await fetch(url, opts);
  } catch (err) {
    apiOnline = false;
    apiLastError = "sem conexao com API";
    applyAccessProfile();
    throw err;
  }

  if (!resp.ok) {
    const t = await resp.text();
    apiOnline = false;
    apiLastError = "HTTP " + resp.status + " " + t;
    applyAccessProfile();
    throw new Error(apiLastError);
  }

  const ct = (resp.headers.get("content-type") || "").toLowerCase();
  if (ct.includes("application/json")) return await resp.json();
  return null;
}

function handleApiSyncError(err, actionName) {
  const msg = err && err.message ? String(err.message) : "falha desconhecida";
  apiOnline = false;
  apiLastError = msg;
  applyAccessProfile();
  console.warn("Falha ao sincronizar " + actionName + " com API:", msg);
}

function normalizeUserRole(roleInput) {
  const role = String(roleInput || "").trim().toUpperCase();
  return USER_ROLE_OPTIONS.includes(role) ? role : "APG";
}

function mkEvent(type, payload) {
  const p = payload || {};
  return {
    at: p.at || isoNow(),
    actor_user: p.actor_user || CURRENT_USER,
    actor_role: p.actor_role || CURRENT_ROLE,
    type: type,
    field: p.field || null,
    from: p.from || null,
    to: p.to || null,
    note: p.note || ""
  };
}

function mkRecord(data) {
  const now = isoNow();
  const rec = {
    id: asText(data.id),
    ano: toInt(data.ano) || currentYear(),
    identificacao: asText(data.identificacao) || "-",
    cod_subfonte: asText(data.cod_subfonte),
    deputado: asText(data.deputado) || "-",
    cod_uo: asText(data.cod_uo),
    sigla_uo: asText(data.sigla_uo),
    cod_orgao: asText(data.cod_orgao),
    cod_acao: asText(data.cod_acao),
    descricao_acao: asText(data.descricao_acao),
    municipio: asText(data.municipio) || "-",
    valor_inicial: toNumber(data.valor_inicial != null ? data.valor_inicial : 0),
    valor_atual: toNumber(data.valor_atual != null ? data.valor_atual : (data.valor_inicial != null ? data.valor_inicial : 0)),
    processo_sei: asText(data.processo_sei),
    status_oficial: normalizeStatus(data.status_oficial || "Recebido"),
    backend_id: data.backend_id != null ? Number(data.backend_id) : null,
    created_at: data.created_at || now,
    updated_at: data.updated_at || now,
    eventos: Array.isArray(data.eventos) && data.eventos.length ? data.eventos : [mkEvent("IMPORT", { note: "Registro criado." })],
    ref_key: "",
    source_sheet: asText(data.source_sheet || "Controle de EPI"),
    source_row: data.source_row != null ? Number(data.source_row) : null,
    all_fields: data.all_fields && typeof data.all_fields === "object" ? shallowCloneObj(data.all_fields) : {}
  };
  syncCanonicalToAllFields(rec);
  rec.ref_key = buildReferenceKey(rec);
  return rec;
}

function normalizeRecordShape(raw) {
  const rec = mkRecord(raw || {});
  rec.id = asText(raw && raw.id ? raw.id : rec.id);
  rec.backend_id = raw && raw.backend_id != null ? Number(raw.backend_id) : rec.backend_id;
  rec.created_at = (raw && raw.created_at) || rec.created_at;
  rec.updated_at = (raw && raw.updated_at) || rec.updated_at;
  rec.eventos = Array.isArray(raw && raw.eventos) && raw.eventos.length ? raw.eventos : rec.eventos;
  if (!rec.valor_inicial && rec.valor_atual) rec.valor_inicial = rec.valor_atual;
  rec.source_sheet = asText((raw && raw.source_sheet) || rec.source_sheet || "Controle de EPI");
  rec.source_row = raw && raw.source_row != null ? Number(raw.source_row) : rec.source_row;
  rec.all_fields = rec.all_fields && typeof rec.all_fields === "object" ? rec.all_fields : {};
  syncCanonicalToAllFields(rec);
  rec.ref_key = buildReferenceKey(rec);
  return rec;
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const parsed = JSON.parse(raw);
      if (parsed && Array.isArray(parsed.records)) return parsed;
    }

    for (let i = 0; i < LEGACY_STORAGE_KEYS.length; i += 1) {
      const legacyRaw = localStorage.getItem(LEGACY_STORAGE_KEYS[i]);
      if (!legacyRaw) continue;
      const parsedLegacy = JSON.parse(legacyRaw);
      if (parsedLegacy && Array.isArray(parsedLegacy.records)) return { records: parsedLegacy.records };
    }

    return { records: deepClone(DEMO) };
  } catch (_err) {
    return { records: deepClone(DEMO) };
  }
}

function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

function buildIdCounters(records) {
  const counters = {};
  records.forEach(function (r) {
    const id = String(r.id || "");
    const m = id.match(/^EPI-(\d{4})-(\d+)$/i);
    if (!m) return;
    const year = m[1];
    const seq = parseInt(m[2], 10) || 0;
    counters[year] = Math.max(counters[year] || 0, seq);
  });
  return counters;
}

function assignMissingIds(records, counters) {
  records.forEach(function (r) {
    if (String(r.id || "").trim()) return;
    r.id = generateInternalId(r.ano, counters);
  });
}

function generateInternalId(ano, counters) {
  const year = String(toInt(ano) || currentYear());
  const next = (counters[year] || 0) + 1;
  counters[year] = next;
  return "EPI-" + year + "-" + String(next).padStart(6, "0");
}

function syncReferenceKeys(records) {
  records.forEach(function (r) {
    r.ref_key = buildReferenceKey(r);
  });
}

function buildReferenceKey(record) {
  const parts = REFERENCE_FIELDS.map(function (field) {
    return normalizeReferencePart(record[field]);
  });
  if (parts.every(function (p) { return p === ""; })) return "";
  return parts.join("|");
}

function normalizeReferencePart(value) {
  return normalizeLooseText(value).replace(/\s+/g, " ").trim();
}

function normalizeLooseText(value) {
  return String(value == null ? "" : value)
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .trim();
}

function normalizeRowKeys(row) {
  const out = {};
  Object.keys(row || {}).forEach(function (k) {
    const nk = normalizeHeader(k);
    if (!nk) return;
    if (out[nk] == null || String(out[nk]).trim() === "") out[nk] = row[k];
  });
  return out;
}

function normalizeHeader(key) {
  return normalizeLooseText(key).replace(/[^a-z0-9]+/g, "_").replace(/^_+|_+$/g, "");
}

function pickValue(normalizedRow, aliases) {
  if (!normalizedRow) return "";
  for (let i = 0; i < aliases.length; i += 1) {
    const nk = normalizeHeader(aliases[i]);
    const raw = normalizedRow[nk];
    if (raw == null) continue;
    const txt = String(raw).trim();
    if (txt !== "") return raw;
  }
  return "";
}

function shallowCloneObj(obj) {
  const out = {};
  Object.keys(obj || {}).forEach(function (k) {
    out[k] = obj[k];
  });
  return out;
}

function mergeRawFields(target, incomingRaw) {
  if (!target.all_fields || typeof target.all_fields !== "object") target.all_fields = {};
  let changed = false;

  Object.keys(incomingRaw || {}).forEach(function (key) {
    const next = incomingRaw[key] == null ? "" : String(incomingRaw[key]);
    const prev = target.all_fields[key] == null ? "" : String(target.all_fields[key]);
    if (prev !== next) {
      target.all_fields[key] = next;
      changed = true;
    }
  });

  return changed;
}

function syncCanonicalToAllFields(record) {
  if (!record.all_fields || typeof record.all_fields !== "object") record.all_fields = {};

  upsertRawField(record.all_fields, "id", record.id);
  upsertRawField(record.all_fields, "ano", record.ano);
  upsertRawField(record.all_fields, "identificacao", record.identificacao);
  upsertRawField(record.all_fields, "cod_subfonte", record.cod_subfonte);
  upsertRawField(record.all_fields, "deputado", record.deputado);
  upsertRawField(record.all_fields, "cod_uo", record.cod_uo);
  upsertRawField(record.all_fields, "sigla_uo", record.sigla_uo);
  upsertRawField(record.all_fields, "cod_orgao", record.cod_orgao);
  upsertRawField(record.all_fields, "cod_acao", record.cod_acao);
  upsertRawField(record.all_fields, "descricao_acao", record.descricao_acao);
  upsertRawField(record.all_fields, "municipio", record.municipio);
  upsertRawField(record.all_fields, "valor_inicial", record.valor_inicial);
  upsertRawField(record.all_fields, "valor_atual", record.valor_atual);
  upsertRawField(record.all_fields, "processo_sei", record.processo_sei);
  upsertRawField(record.all_fields, "status_oficial", record.status_oficial);
}

function upsertRawField(rawObj, canonicalKey, value) {
  const aliases = IMPORT_ALIASES[canonicalKey] || [];
  const preferred = RAW_PREFERRED_HEADERS[canonicalKey] || canonicalKey;
  const normalizedAliases = aliases.map(function (a) { return normalizeHeader(a); });

  let keyFound = null;
  Object.keys(rawObj).forEach(function (k) {
    if (keyFound) return;
    if (normalizedAliases.includes(normalizeHeader(k))) keyFound = k;
  });

  const finalKey = keyFound || preferred;
  rawObj[finalKey] = value == null ? "" : value;
}

function showImportReport(report) {
  if (!importReport) return;
  importReport.classList.remove("hidden");
  const sheets = report.sheetNames.length ? report.sheetNames.join(", ") : "-";

  const planilha1Aoa = buildPlanilha1Aoa(state.records || []);
  const planilha1Html = buildPlanilha1Html(planilha1Aoa);

  importReport.innerHTML = ""
    + "<h4>Resumo da importacao</h4>"
    + "<p class=\"muted small\">Arquivo: " + escapeHtml(report.fileName) + " | Abas lidas: " + escapeHtml(sheets) + "</p>"
    + "<div class=\"import-tabs\" role=\"tablist\" aria-label=\"Abas do relatorio de importacao\">"
    + "  <button type=\"button\" class=\"import-tab-btn active\" data-import-tab=\"resumo\" role=\"tab\" aria-selected=\"true\">Resumo da importacao</button>"
    + "  <button type=\"button\" class=\"import-tab-btn\" data-import-tab=\"planilha1\" role=\"tab\" aria-selected=\"false\">Planilha1 (Deputados)</button>"
    + "</div>"
    + "<div class=\"import-tab-panels\">"
    + "  <section class=\"import-tab-panel active entering\" data-import-panel=\"resumo\">"
    + "    <div class=\"kv\" style=\"margin-top:8px\">"
    + "      <div class=\"k\">Linhas lidas</div><div class=\"v\">" + String(report.totalRows) + "</div>"
    + "      <div class=\"k\">Linhas validas</div><div class=\"v\">" + String(report.consideredRows) + "</div>"
    + "      <div class=\"k\">Linhas ignoradas</div><div class=\"v\">" + String(report.skippedRows) + "</div>"
    + "      <div class=\"k\">Novos registros</div><div class=\"v\">" + String(report.created) + "</div>"
    + "      <div class=\"k\">Registros atualizados</div><div class=\"v\">" + String(report.updated) + "</div>"
    + "      <div class=\"k\">Sem alteracao</div><div class=\"v\">" + String(report.unchanged) + "</div>"
    + "      <div class=\"k\">Duplicidade por ID</div><div class=\"v\">" + String(report.duplicateById) + "</div>"
    + "      <div class=\"k\">Duplicidade por chave ref</div><div class=\"v\">" + String(report.duplicateByRef) + "</div>"
    + "      <div class=\"k\">Duplicidade dentro do arquivo</div><div class=\"v\">" + String(report.duplicateInFile) + "</div>"
    + "      <div class=\"k\">Conflito ID x chave ref</div><div class=\"v\">" + String(report.conflictIdVsRef) + "</div>"
    + "    </div>"
    + "  </section>"
    + "  <section class=\"import-tab-panel import-report-right\" data-import-panel=\"planilha1\">"
    + "    <h4 style=\"margin-bottom:8px\">Resumo por deputado (Planilha1)</h4>"
    + planilha1Html
    + "  </section>"
    + "</div>";

  wireImportReportTabs("resumo");
}

function wireImportReportTabs(defaultTab) {
  if (!importReport) return;
  const tabButtons = Array.from(importReport.querySelectorAll("[data-import-tab]"));
  const tabPanels = Array.from(importReport.querySelectorAll("[data-import-panel]"));
  if (!tabButtons.length || !tabPanels.length) return;

  function activateTab(tabName) {
    tabButtons.forEach(function (btn) {
      const active = btn.getAttribute("data-import-tab") === tabName;
      btn.classList.toggle("active", active);
      btn.setAttribute("aria-selected", active ? "true" : "false");
    });

    tabPanels.forEach(function (panel) {
      const active = panel.getAttribute("data-import-panel") === tabName;
      panel.classList.toggle("active", active);
      if (active) {
        panel.classList.remove("entering");
        void panel.offsetWidth;
        panel.classList.add("entering");
      }
    });
  }

  tabButtons.forEach(function (btn) {
    btn.addEventListener("click", function () {
      activateTab(btn.getAttribute("data-import-tab"));
    });
  });

  activateTab(defaultTab || tabButtons[0].getAttribute("data-import-tab"));
}
function buildPlanilha1Html(aoa) {
  if (!Array.isArray(aoa) || aoa.length === 0) {
    return "<p class=\"muted small\">Sem dados para resumo por deputado.</p>";
  }

  let html = "<div class=\"table-wrap\"><table class=\"table\" style=\"min-width:420px\"><thead><tr><th>" + escapeHtml(String(aoa[0][0] || "RÃ³tulos de Linha")) + "</th><th>" + escapeHtml(String(aoa[0][1] || "Contagem")) + "</th></tr></thead><tbody>";

  for (let i = 1; i < aoa.length; i += 1) {
    const row = aoa[i] || [];
    const label = row[0] == null ? "" : String(row[0]);
    const val = row[1] == null ? "" : String(row[1]);
    const isTotal = normalizeLooseText(label) === "total geral";
    html += "<tr" + (isTotal ? " style=\"font-weight:700\"" : "") + "><td>" + escapeHtml(label) + "</td><td>" + escapeHtml(val) + "</td></tr>";
  }

  html += "</tbody></table></div>";
  return html;
}

function hideImportReport() {
  if (!importReport) return;
  importReport.classList.add("hidden");
  importReport.innerHTML = "";
}

function toCsv(records) {
  const table = buildExportTableData(records);
  const headers = table.headers;
  const lines = [headers.join(",")];
  table.rows.forEach(function (rowObj) {
    lines.push(headers.map(function (h) { return csvCell(rowObj[h]); }).join(","));
  });
  return lines.join("\n");
}

function exportRecordsToXlsx(records, filename) {
  const xlsxApi = typeof window !== "undefined" ? window.XLSX : null;
  if (!xlsxApi) {
    alert("Biblioteca XLSX nao carregada.");
    return;
  }

  const dataTable = buildExportTableData(records);
  const dataAoa = [dataTable.headers].concat(dataTable.rows.map(function (rowObj) {
    return dataTable.headers.map(function (h) { return rowObj[h] == null ? "" : rowObj[h]; });
  }));

  const auditTable = buildAuditLogTableData(records);
  const summaryAoa = buildSummaryAoa(records, auditTable.rows.length);
  const auditAoa = [auditTable.headers].concat(auditTable.rows.map(function (rowObj) {
    return auditTable.headers.map(function (h) { return rowObj[h] == null ? "" : rowObj[h]; });
  }));
  const auditSheetAoa = summaryAoa.concat([[]]).concat(auditAoa);

  const wsData = xlsxApi.utils.aoa_to_sheet(dataAoa);
  const wsAudit = xlsxApi.utils.aoa_to_sheet(auditSheetAoa);
  const wsPlanilha1 = xlsxApi.utils.aoa_to_sheet(buildPlanilha1Aoa(records));
  const wb = xlsxApi.utils.book_new();
  xlsxApi.utils.book_append_sheet(wb, wsPlanilha1, "Planilha1");
  xlsxApi.utils.book_append_sheet(wb, wsData, "Controle de EPI");
  xlsxApi.utils.book_append_sheet(wb, wsAudit, "Resumo_AuditLog");
  xlsxApi.writeFile(wb, filename || ("emendas_export_" + dateStamp() + ".xlsx"));
}

function buildExportTableData(records) {
  const extraHeaders = [];
  const extraSet = new Set();

  records.forEach(function (r) {
    const raw = r && r.all_fields && typeof r.all_fields === "object" ? r.all_fields : {};
    Object.keys(raw).forEach(function (k) {
      if (!extraSet.has(k)) {
        extraSet.add(k);
        extraHeaders.push(k);
      }
    });
  });

  const systemHeaders = ["id_interno_sistema", "backend_id", "status_oficial_sistema", "ref_key", "created_at", "updated_at", "source_sheet", "source_row"];
  const headers = extraHeaders.concat(systemHeaders);

  const rows = records.map(function (r) {
    const out = {};
    const raw = r && r.all_fields && typeof r.all_fields === "object" ? r.all_fields : {};

    extraHeaders.forEach(function (h) {
      out[h] = raw[h] == null ? "" : raw[h];
    });

    out.id_interno_sistema = r.id || "";
    out.backend_id = r.backend_id == null ? "" : r.backend_id;
    out.status_oficial_sistema = r.status_oficial || "";
    out.ref_key = r.ref_key || "";
    out.created_at = r.created_at || "";
    out.updated_at = r.updated_at || "";
    out.source_sheet = r.source_sheet || "";
    out.source_row = r.source_row == null ? "" : r.source_row;
    return out;
  });

  return { headers: headers, rows: rows };
}

function buildAuditLogTableData(records) {
  const headers = [
    "id_interno_sistema",
    "identificacao",
    "municipio",
    "deputado",
    "status_oficial_atual",
    "data_hora_evento",
    "tipo_evento",
    "usuario",
    "setor",
    "campo",
    "valor_antigo",
    "valor_novo",
    "motivo",
    "source_sheet",
    "source_row"
  ];

  const rows = [];
  records.forEach(function (r) {
    const orderedEvents = getEventsSorted(r);
    orderedEvents.forEach(function (ev) {
      rows.push({
        id_interno_sistema: r.id || "",
        identificacao: r.identificacao || "",
        municipio: r.municipio || "",
        deputado: r.deputado || "",
        status_oficial_atual: r.status_oficial || "",
        data_hora_evento: ev.at || "",
        tipo_evento: ev.type || "",
        usuario: ev.actor_user || "",
        setor: ev.actor_role || "",
        campo: ev.field || "",
        valor_antigo: ev.from == null ? "" : ev.from,
        valor_novo: ev.to == null ? "" : ev.to,
        motivo: ev.note || "",
        source_sheet: r.source_sheet || "",
        source_row: r.source_row == null ? "" : r.source_row
      });
    });
  });

  rows.sort(function (a, b) {
    const ta = new Date(a.data_hora_evento).getTime() || 0;
    const tb = new Date(b.data_hora_evento).getTime() || 0;
    return tb - ta;
  });

  return { headers: headers, rows: rows };
}

function buildSummaryAoa(records, totalEvents) {
  const now = new Date().toISOString();
  const byStatus = {};
  STATUS.forEach(function (s) {
    byStatus[s] = 0;
  });

  records.forEach(function (r) {
    const st = normalizeStatus(r.status_oficial);
    byStatus[st] = (byStatus[st] || 0) + 1;
  });

  const out = [
    ["Resumo da exportacao"],
    ["Gerado em", now],
    ["Total de emendas", records.length],
    ["Total de eventos (audit log)", totalEvents],
    [],
    ["Status Oficial", "Quantidade"]
  ];

  STATUS.forEach(function (s) {
    out.push([s, byStatus[s] || 0]);
  });

  return out;
}

function buildPlanilha1Aoa(records) {
  const byDeputado = {};
  records.forEach(function (r) {
    const nome = (r.deputado || "").trim() || "(Sem deputado)";
    byDeputado[nome] = (byDeputado[nome] || 0) + 1;
  });

  const ordered = Object.keys(byDeputado).sort(function (a, b) {
    return a.localeCompare(b, "pt-BR");
  });

  const out = [
    ["RÃ³tulos de Linha", "Contagem de Deputado"],
    ["Indicar escola", records.length]
  ];

  ordered.forEach(function (nome) {
    out.push([nome, byDeputado[nome]]);
  });

  out.push(["Total Geral", records.length]);
  return out;
}

function csvCell(v) {
  const s = v == null ? "" : String(v);
  if (/[,"\n]/.test(s)) return "\"" + s.replace(/"/g, "\"\"") + "\"";
  return s;
}

function downloadCsv(filename, content) {
  const blob = new Blob([content], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function parseCsv(text) {
  const delimiter = detectDelimiter(text);
  return parseDelimited(text, delimiter);
}

function detectDelimiter(text) {
  const lines = String(text || "").split(/\r?\n/).filter(function (ln) {
    return ln.trim() !== "";
  });
  if (!lines.length) return ",";

  const sample = lines[0];
  const countComma = (sample.match(/,/g) || []).length;
  const countSemi = (sample.match(/;/g) || []).length;
  const countTab = (sample.match(/\t/g) || []).length;

  if (countSemi > countComma && countSemi >= countTab) return ";";
  if (countTab > countComma && countTab > countSemi) return "\t";
  return ",";
}

function parseDelimited(text, delimiter) {
  const rows = [];
  let i = 0;
  let field = "";
  let row = [];
  let inQuotes = false;

  function pushField() {
    row.push(field);
    field = "";
  }

  function pushRow() {
    rows.push(row);
    row = [];
  }

  while (i < text.length) {
    const ch = text[i];

    if (inQuotes) {
      if (ch === "\"") {
        const next = text[i + 1];
        if (next === "\"") {
          field += "\"";
          i += 2;
          continue;
        }
        inQuotes = false;
        i += 1;
        continue;
      }
      field += ch;
      i += 1;
      continue;
    }

    if (ch === "\"") {
      inQuotes = true;
      i += 1;
      continue;
    }
    if (ch === delimiter) {
      pushField();
      i += 1;
      continue;
    }
    if (ch === "\n") {
      pushField();
      pushRow();
      i += 1;
      continue;
    }
    if (ch === "\r") {
      i += 1;
      continue;
    }

    field += ch;
    i += 1;
  }

  pushField();
  pushRow();

  const header = (rows.shift() || []).map(function (h) {
    return String(h || "").trim();
  });

  return rows.filter(function (r) {
    return r.some(function (cell) {
      return String(cell || "").trim() !== "";
    });
  }).map(function (r) {
    const obj = {};
    header.forEach(function (h, idx) {
      obj[h] = String(r[idx] || "").trim();
    });
    return obj;
  });
}

function fmtMoney(n) {
  const x = toNumber(n);
  return x.toLocaleString("pt-BR", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
}

function fmtDateTime(iso) {
  try {
    const d = new Date(iso);
    return d.toLocaleString("pt-BR");
  } catch (_err) {
    return String(iso || "");
  }
}

function isoNow() {
  return new Date().toISOString();
}

function dateStamp() {
  const d = new Date();
  const yyyy = d.getFullYear();
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  const hh = String(d.getHours()).padStart(2, "0");
  const mi = String(d.getMinutes()).padStart(2, "0");
  return yyyy + mm + dd + "_" + hh + mi;
}

function currentYear() {
  return new Date().getFullYear();
}

function toInt(v) {
  const n = parseInt(v, 10);
  return Number.isFinite(n) ? n : 0;
}

function toNumber(v) {
  if (typeof v === "number") return Number.isFinite(v) ? v : 0;
  const s = String(v == null ? "" : v).trim().replace(/\s/g, "").replace(/\.(?=\d{3}(\D|$))/g, "").replace(/,/g, ".").replace(/[^\d.-]/g, "");
  const n = Number(s);
  return Number.isFinite(n) ? n : 0;
}

function toNumberOrNull(v) {
  if (v == null) return null;
  const txt = String(v).trim();
  if (txt === "") return null;
  const n = toNumber(txt);
  if (!Number.isFinite(n)) return null;
  return n;
}

function asText(v) {
  if (v == null) return "";
  return String(v).trim();
}

function text(v) {
  return asText(v);
}

function escapeHtml(str) {
  return String(str).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#039;");
}

function debounce(fn, ms) {
  let t = null;
  return function () {
    const args = arguments;
    clearTimeout(t);
    t = setTimeout(function () {
      fn.apply(null, args);
    }, ms);
  };
}

function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

